---
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(palmerpenguins)
library(tidyverse)
library(knitr)
```

# Wrangling Data

_explanation/something goofy about data wrangling_

### Data Frames and `tibble`s

_yada yada about data frames and tibbles_ - biggest thing to note here is that the print method (i.e. what happens when you just type the name of a data frame) is much better than that for normal data frames

### Tidy Data Principles, Reshaping Data, and `tidyr`

Packages in the `tidyverse`, like `ggplot2` and `dplyr`, are built to work with tidy data. The `tidyr` package can help us tidy up a dataset by rearranging how data is structured.

Briefly, for a dataset to be tidy, it must follow these three rules:

1. Each variable must have its own column

2. Each observation must have its own row

3. Each value must have its own cell

Let's take a look at a summarized version of the `penguins` data as an example:

```{r, echo = FALSE, message = FALSE, warning = FALSE}
penguins_sum <- penguins %>%
  group_by(island, year) %>%
  summarize(mean_body_mass_g = mean(body_mass_g, na.rm= TRUE))

penguins_sum
```



Each variable has its own column, each observation (the sample of penguins on a given island in a given year) is a row, and each value has its own cell.

This dataset, though, could also look like this:

```{r}
penguins_sum %>%
  pivot_wider(id_cols = c("island", "year"), names_from = year, values_from = mean_body_mass_g)
```

This dataset technically contains the same data, but in this version, the mean body mass is held in three different columns!

Sometimes, the data you're asked to analyze might look more like the second, untidy version than the first, tidy version. How do you move from one to the other? Introducing `tidyr`!

Let's start off with the first version:

```{r, message = FALSE, warning = FALSE}
penguins_sum
```

We want to "pivot" this data from a "long" format to a "wide" format. The `pivot_wider()` function from `tidyr` will help us to do that:

```{r, warning = FALSE, message = FALSE}
penguins_wide <- penguins_sum %>%
  pivot_wider(id_cols = c("island", "year"), 
              names_from = year, 
              values_from = mean_body_mass_g)

penguins_wide
```

The `id_cols` (read: ID columns) are the variables that, together, identify what makes a row unique in the original data, `names_from` determines what columns in the old data will be the names of the new columns, and `values_from` is the name of the variable in the old data that will be the information contained inside the new columns.

What if we want pivot from wider to longer, though? You might have guessed it! `pivot_longer()`! Starting with the widened version of the data:

```{r}
penguins_wide %>%
  pivot_longer(cols = c("2007", "2008", "2009"), 
               names_to = "year",
               values_to = "mean_body_mass_g")
```

As you might have noticed, `pivot_longer()` and `pivot_wider()` are inverse operations! Pivoting a widened dataset to a longer format gives you back the original dataset, and vice versa.

If you're interested in learning more about tidy data and pivoting, we recommend the chapter in [R for Data Science](https://r4ds.had.co.nz/tidy-data.html)!

### Transforming Data With `dplyr`

Now that our data is tidy we can use `dplyr` to further transform our data!

There are 6 fundamental `dpylr` functions that should allow you to perform the data wrangling that you find yourself needing to do. For the following examples we'll be using the full `penguins` data set.

Whenever you see the `head()` function used, you can think of it as a way for us to take a peek at what our transformations are doing!

First of all we can use it to get a feel for what our variables are and what their values might look like:

```{r}
penguins %>%
  head()
```

#### 1. Filtering rows

Let's say that you want to take a subset of your full data set, by only picking rows that meet certain criteria. For example, in our penguins data set we could choose to look at female penguins only:

```{r}
penguins %>%
  filter(sex == "female")%>%
  head()
```

Or perhaps we want to only look at penguins with a bill length that's less than 40mm:

```{r}
penguins %>%
  filter(bill_length_mm < 40) %>%
  head()
```

We can get as specific as we want. Suppose we want to look at the penguins from Trogersen island in 2008 with a body mass greater than 3500 grams:

```{r}
penguins %>%
  filter(island == "Torgersen" & year == 2008 & body_mass_g > 3500 ) %>% #is it more intuitive to do this example with & or ,?
  head()
```

#### 2. Arranging rows

We can arrange our data, by a certain variable using the `arrange()` function

For arranging by quantitative variable, in ascending order:

```{r}
penguins %>%
  arrange(bill_length_mm)%>%
  head()
```

and if we wanted to put it in descending order?

```{r}
penguins %>%
  arrange(desc(bill_length_mm)) %>%
  head()
```

And if we want to arrange by a categorical variable it works alphabetically:

```{r}
penguins %>%
  arrange(species) %>%
  head()
```

#### 3. Select

A data set can have a ton of different variables, but sometimes we're only interested in a few. We can use the `select()` function to do just that! All you have to do is add all of the variables that you want inside of the function.

```{r}
penguins %>%
  select(species, island, sex) %>%
  head()
```

#### 4. Mutate

What if you wanted create a new column or "mutate" an existing column in some way? The `mutate()` function makes both of these things easy! For this example we'll go back to using our `penguins_sum` data frame.

If we want to introduce a new column we choose a name for it and then indicate how we want to calculate it. For example we'll create a new column for the mean body mass in kilograms instead of grams:

```{r}
penguins_sum %>%
  mutate(mean_body_mass_kg = (mean_body_mass_g/1000))
  
```

If for some reason all of our years were off by 1 we could just change the original column like this:

```{r}
penguins_sum %>%
  mutate(year = year +1)
```



#### 5. Summarize and grouped summarize

You might have noticed that the functions `group_by()` and `summarize()` were used in our explanation of tidy data with the data frame `penguins_sum`. Let's work step-by-step from our original data set to `penguins_sum` to get a better feel for what that code was doing!

We want to end up with a data frame that shows the mean body mass of penguins for each island and each year. We can feed both of those variables into the `group_by()` to start:

```{r}
penguins %>%
  group_by(island, year) %>%
  head()
```
Notice how this code didn't actually change the way our data frame looks. This is because the `group_by()` function changes the metadata, you can think of this as R getting the data frame ready for a further transformation to be applied to it. We can apply the `summarize` function to get what we want!

```{r}
penguins %>%
  group_by(island, year) %>%
  summarise(mean_body_mass_g = mean(body_mass_g, na.rm = TRUE))
```

all that the `na.rm = TRUE` is doing is removing any NA values in `body_mass_g` so that we dont get any NA values in our final data frame.

If we wanted to do something similar to this, but only look at mean body mass for each year, we can simply remove `island` from our `group_by()` function:

```{r}
penguins %>%
  group_by(year) %>%
  summarise(mean_body_mass_g = mean(body_mass_g, na.rm = TRUE))
```

###Frequency tables

Frequency tables can be a helpful way of displaying information about your data. For example, what if we want to know how many male and female penguins are in our sample? We can build a frequency table for this. 

First, we'll need to `group_by()` the variable that we want to count, and then we'll `count()` frequencies by that variable!

```{r}
penguins %>%
  group_by(sex) %>%
  count()
```

Now we can easily see that our sample includes 165 females, 168 males, and 11 rows have an NA value in that column. 

What if we want to see how many males and females were sampled on each island? We can simply `group_by()` island and sex, and then `count()`!

```{r}
penguins %>%
  group_by(island, sex) %>%
  count()
```

`count()` is a quick and easy way to produce frequency tables in R


_yada yada about data transformation_