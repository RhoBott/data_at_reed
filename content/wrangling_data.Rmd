---
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(palmerpenguins)
library(tidyverse)
library(knitr)
```

# Wrangling Data

When you first get a dataset, whether it's from a class, downloaded from the internet, or given to you by a professor, there might be ways that you want to change that data to make it easier to work with, add more information, or summarize your data. These all fall under the term "Data Wrangling". Let's learn how to handle our data, how to get more out of it, and how to keep it tidy.

### Data Frames and `tibble`s

<!-- _yada yada about data frames and tibbles_ - biggest thing to note here is that the print method (i.e. what happens when you just type the name of a data frame) is much better than that for normal data frames -->

### Tidy Data Principles, Reshaping Data, and `tidyr`

Packages in the `tidyverse`, like `ggplot2` and `dplyr`, are built to work with tidy data. The `tidyr` package can help us tidy up a dataset by rearranging how data is structured.

Briefly, for a dataset to be tidy, it must follow these three rules:

1. Each variable must have its own column

2. Each observation must have its own row

3. Each value must have its own cell

Let's take a look at a summarized version of the `penguins` data as an example.
(For instructions on loading `penguins`, see our [Getting Started](LINK-HERE) page)

<!-- _here_ maybe we should add something about how and why we are summarizing the data -->

For our summarized `penguins` data, we want to have the mean body mass for all penguins on a given island in a given year. To do this, we use the `dplyr` function `group_by` which takes the original data and groups it by the given variable (or variables, in this case island and year). Then with `summarize` we can calculate the grouped mean body weights, and we get one table with the mean body mass for all penguins on a given island in a given year.

```{r, echo = FALSE, message = FALSE, warning = FALSE}
penguins_sum <- penguins %>%
  group_by(island, year) %>%
  summarize(mean_body_mass_g = mean(body_mass_g, na.rm= TRUE))

penguins_sum
```


Each variable has its own column, each observation (the sample of penguins on a given island in a given year) is a row, and each value has its own cell.

This dataset, though, could also look like this:

```{r}
penguins_sum %>%
  pivot_wider(id_cols = c("island", "year"), names_from = year, values_from = mean_body_mass_g)
```

This dataset technically contains the same data, but in this version, the mean body mass is held in three different columns- one for each year.

Sometimes, the data you're asked to analyze might look more like the second, untidy version than the first, tidy version. How do you move from one to the other? Introducing `tidyr`!

Let's start off with the first version:

```{r, message = FALSE, warning = FALSE}
penguins_sum
```

We want to "pivot" this data from a "long" format to a "wide" format. The `pivot_wider()` function from `tidyr` will help us to do that:

```{r, warning = FALSE, message = FALSE}
penguins_wide <- penguins_sum %>%
  pivot_wider(id_cols = c("island", "year"), 
              names_from = year, 
              values_from = mean_body_mass_g)

penguins_wide
```

The `id_cols` (read: ID columns) are the variables that, together, identify what makes a row unique in the original data, `names_from` determines what columns in the old data will be the names of the new columns, and `values_from` is the name of the variable in the old data that will be the information contained inside the new columns.

What if we want pivot from wider to longer, though? You might have guessed it! `pivot_longer()`! Starting with the widened version of the data:

```{r}
penguins_wide %>%
  pivot_longer(cols = c("2007", "2008", "2009"), 
               names_to = "year",
               values_to = "mean_body_mass_g")
```

As you might have noticed, `pivot_longer()` and `pivot_wider()` are inverse operations! Pivoting a widened dataset to a longer format gives you back the original dataset, and vice versa.

If you're interested in learning more about tidy data and pivoting, we recommend the chapter in [R for Data Science](https://r4ds.had.co.nz/tidy-data.html)!

### Transforming Data With `dplyr`

Now that our data is tidy we can use `dplyr` to further transform our data!

There are 6 fundamental `dpylr` functions that should allow you to perform the data wrangling that you find yourself needing to do. For the following examples we'll be using the full `penguins` data set.

Whenever you see the `head()` function used, you can think of it as a way for us to take a peek at what our transformations are doing!

First of all we can use it to get a feel for what our variables are and what their values might look like:

```{r}
penguins
```

#### 1. Filtering Rows with `filter()`

Let's say that you want to take a subset of your full data set, by only picking rows that meet certain criteria. For example, in our penguins data set we could choose to look at female penguins only:

```{r}
penguins %>%
  filter(sex == "female")
```

Or perhaps we want to only look at penguins with a bill length that's less than 40mm:

```{r}
penguins %>%
  filter(bill_length_mm < 40)
```

We can get as specific as we want. Suppose we want to look at the penguins from Trogersen island in 2008 with a body mass greater than 3500 grams:

```{r}
penguins %>%
  filter(island == "Torgersen" & year == 2008 & body_mass_g > 3500 )
```

#### 2. Arranging Rows with `arrange()`

We can arrange our data, by a certain variable using the `arrange()` function

For arranging by quantitative variable, in ascending order:

```{r}
penguins %>%
  arrange(bill_length_mm)
```

and if we wanted to put it in descending order?

```{r}
penguins %>%
  arrange(desc(bill_length_mm))
```

Given a categorical variable, `dplyr` will arrange alphabetically.

```{r}
penguins %>%
  arrange(species)
```

#### 3. Selecting Columns with `select()`

A data set can have a ton of different variables, but sometimes we're only interested in a few. We can use the `select()` function to do just that! All you have to do is add all of the variables that you want inside of the function.

```{r}
penguins %>%
  select(species, island, sex)
```

#### 4. Creating New Columns with `mutate()`

What if you wanted create a new column or "mutate" an existing column in some way? The `mutate()` function makes both of these things easy! For this example we'll go back to using our `penguins_sum` data frame.

If we want to introduce a new column we choose a name for it and then indicate how we want to calculate it. For example we'll create a new column for the mean body mass in kilograms instead of grams:

```{r}
penguins_sum %>%
  mutate(mean_body_mass_kg = (mean_body_mass_g / 1000))
```

If for some reason all of our years were off by 1 we could just change the original column like this:

```{r}
penguins_sum %>%
  mutate(year = year + 1)
```

#### 5. Summarizing Data with `group_by()` and `summarize()`

You might have noticed that the functions `group_by()` and `summarize()` were used in our explanation of tidy data with the data frame `penguins_sum`. Let's work step-by-step from our original data set to `penguins_sum` to get a better feel for what that code was doing!

We want to end up with a data frame that shows the mean body mass of penguins for each island and each year. We can feed both of those variables into the `group_by()` to start:

```{r}
penguins %>%
  group_by(island, year)
```

Notice how this code didn't actually change the way our data frame looks. This is because the `group_by()` function changes the metadata, you can think of this as R getting the data frame ready for a further transformation to be applied to it. We can apply the `summarize` function to get what we want!

```{r}
penguins %>%
  group_by(island, year) %>%
  summarise(mean_body_mass_g = mean(body_mass_g, na.rm = TRUE))
```

All that the `na.rm = TRUE` is doing is removing any missing values in `body_mass_g` so that we don't report missing values in our summary.

If we wanted to do something similar to this, but only look at mean body mass for each year, we can simply remove `island` from our `group_by()` function:

```{r}
penguins %>%
  group_by(year) %>%
  summarise(mean_body_mass_g = mean(body_mass_g, na.rm = TRUE))
```

If you want to learn more about `dplyr`, [the package's website](https://dplyr.tidyverse.org/) contains a more extensive overview of the package and its functions. You might also check out the [data transformation chapter](https://r4ds.had.co.nz/transform.html) of the R for Data Science book.

#### Frequency Tables with `count()`

Frequency tables can be a helpful way of displaying information about your data. For example, what if we want to know how many male and female penguins are in our sample? We can build a frequency table for this. 

To do so, we can `count()` by the groups formed by splitting up any number of variables. First, by `sex`:

```{r}
penguins %>%
  count(sex)
```

Now we can easily see that our sample includes 165 females, 168 males, and 11 rows have an NA value in that column. 

What if we want to see how many males and females were sampled on each island? We can simply `count()` by `island` and `sex`:

```{r}
penguins %>%
  count(island, sex)
```

`count()` is a quick and easy way to produce frequency tables in R.

### strings with `stringr`

Often times you find yourself with a data set that includes data in the form of a string. Strings are most often represented as `"text surrounded in quotes"` in R. The package `stringr` is really useful tool for working with this type of data, and thankfully is already included in the `tidyverse` package. If you've already loaded the `tidyverse` with `library(tidyverse)`, then you're ready to jump in.

Instead of going through a step-by-step tutorial on exactly how each `stringr` function works, we'll go through a couple of concrete examples using the `penguins` dataset to show off different ways to use `stringr` in your data wrangling.

Most all functions you will want to use from the `stringr` function begin with `str_`. If you ever forget the name of the function you need, try just typing `str_` and scrolling through the auto-completed list of functions exported from `stringr`.

String manipulations are carried out with the use of _patterns_, specified with a language called _regular expressions_ (or "regex", for short). Regular expressions are just shorthand ways of specifying general patterns that you wish to match in data. The following symbols might be helpful in getting started:

1. `^x` : means 'begins with x'
2. `x$` : means 'ends with x'
3. `x{n}` : means exactly n occurrences of x
4. `x{n,}` : means n or more occurrences of x
5. `x{n,m}` : between n and m occurrences of x
6. `[xyz]` : means 'includes x or y or z'

We'll demo what each of these looks like in context below.

Here, we're filtering our data to only look at penguin species that start with the letter 'A' who belong to an island that ends with the letter 'm'.

```{r}
penguins %>%
  filter(str_detect(species, "^A") & str_detect(island, "m$")) %>%
  head()
```

If you're comfortable with `dplyr` you may be realizing that this is not the most efficient way to solve this problem as we could very easily use `filter(species == "Adelie" & island == "Dream")`, but if you were dealing with a data set that had text that wasn't split into factors, using `str_detect()` makes a lot of things possible.

For example, imagine that you were looking at a data set that had a column called 'name' which included the names of 100 different species of fish. You could use the code above to only look at species that started or ended with a certain letter.

This can be extended beyond just a letter, so that we can look for observations that start or end with any given combination of characters:

```{r}
penguins %>%
  filter(str_detect(species, "^Adeli")) %>%
  head()
```

Next, we'll take a look at an example where we want to only look at species that end in 1 or 2 "o's", and then we use a helpful function called `str_to_upper()' to capitalize the names of those species:

```{r}
penguins_edited <- penguins %>%
  filter(str_detect(species, "o{1,2}$"))%>%
  mutate(species = str_to_upper(species)) %>%
  head()

penguins_edited
```

Of course, there's also a corresponding `str_to_lower()` function. 

Following off of our previous code, we can then use a function called `str_remove()` to drop two "O's" from the end of each one (when they exist). You don't get to see it here but if some of our species ended with three "O's" our code would have only the first two.

```{r}
penguins_edited %>%
  mutate(species = str_remove(species,"O{2}$")) %>%
  head()
```

This can be especially useful when you have observations that have a prefix or a suffix that you don't want.

One important thing to note is that your inputs into `str_*` functions are usually case-sensitive.

The last function that we'll show here will be `str_replace()`. In this example we'll replace the "e" at the end of "Biscoe" with "otti". 

```{r}
penguins %>%
  filter(island == "Biscoe") %>%
  mutate(island = str_replace(island, "e", "tti")) %>%
  head()
```

This is a somewhat silly example, but there are plenty of situations in which making replacements such as these will be important for a project you might be working on.

If you want to replace patterns more extensively, you can use `str_replace_all()`. Here we replaced all occurrences of vowels with "x".

```{r}
penguins %>%
  mutate(species = str_replace_all(species, "[aeiou]", "x")) %>%
  head()
```

If you want to learn more about `stringr`, [the package's website](https://stringr.tidyverse.org/) contains a more extensive overview of the package and its functions. You might also check out the [Strings chapter](https://r4ds.had.co.nz/strings.html) of the R for Data Science book.
