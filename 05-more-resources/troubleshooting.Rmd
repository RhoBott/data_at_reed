---
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(palmerpenguins)
```

### Troubleshooting


#### First steps

Below we outline four different tips for approaching troubleshooting your code. That being said, sometimes when your code isn't working properly or you're getting a weird error it's just a small syntactical mistake.

A good list of things to quickly look for are:

  - Misspelled words, functions, or names of datasets and variables
  - Missing commas
  - Unclosed and/or extra parentheses or brackets
  - Missing pipes `%>%` to connect code
  - Missing plus signs `+` to connect `ggplot()` code
  - All necessary packages and data loaded
  - Using the correct file path when trying to load in data or objects

Additionally sometimes RStudio can just get a little bit confused or backed up, so saving your work and restarting RStudio can fix the problem. The "try turning it off and on again" method can sometimes be effective. 

If you've run through the above list of things to check and you're still getting an error or your code isn't functioning properly, it's time to move on to the steps outlined below.


#### Getting information about a function in RStudio

You can always look up a function name on the internet and read it's documentation, but most R packages and functions have help files that can be accessed through the RStudio Console.

For example, if you can't quite remember what arguments should be used for a function, you can type `?function_name` into the console and hit enter. This will load up the help file for that function in the RStudio Help panel which has several useful pieces of information:

  - Usage: a general description of the function as well as it's default arguments
  - Arguments: a more detailed breakdown of the function's inputs/arguments. This is particularly useful for finding out what types of objects the function accepts as arguments
  - Value: A description of what the output of the function will be
  - Examples: Some code that shows off a common way to use the function
  
For example, running the following code will bring up the help file for the `mean()` function.

```{r}
?mean
```

A fairly common problem with using the `mean` function is to run something like this:

```{r}
mean(1,2,3)
```

The above code will not produce an error, but it will output 1 which we know is not the mean of 1, 2, and 3. By looking at the help file we can figure out that the values that we want to find the mean of should all be in the first argument. We can see this both in the "Usage" section and also the "Examples' section. The correct code looks like this:

```{r}
mean(c(1,2,3))
```

which works properly, outputting a mean of 2.


#### Troubleshooting variable types

A fairly common error message to get is something along the lines of

"argument is not ____ " or " non- ____ argument to a ___ function" or "NAs introduced by coercion"

These often have to do with an argument or variable being the wrong type. For example, you might be trying to perform a mathematical operation (like taking the mean) on a character vector (like days of the week). There are a couple of good ways to check variable types:

Using `class` we can check the types of vectors and values. For example the output of running the following chunk will be "numeric", "character", and "logical"

```{r}
class(1)
class("a")
class(NA)
```

We can use the same function to check the class of a variable in our dataset, using the following syntax:

```{r eval = FALSE}
class(data_frame_name$variable_name)
```

If you want an overview of all the variables in your dataset, you can use the `str()` function like this:

```{r eval = FALSE}
str(data_frame_name)
```

The above code will give a breakdown of all the variables and their corresponding types.

Some common variable types you will see are:  
- "int" (integer)
- "num" (numeric)  
- "chr" (character)  
- "Factor with [x] levels"  


In order to fix an error with variable type, you will need to know how to change the type (or class) of a variable. The suite of `as.*` functions is quite useful. Generally the syntax is `as.desired_type(object_that_needs_converting)`.

For example, if a column in our dataset has numbers, but R is treating them as characters (type "chr") instead, we can use the function `as.numeric()` like this:

```{r eval = FALSE}
numeric_var <- as.numeric(character_var)
```

Inside of a dataframe, this code often looks something like this:

```{r eval = FALSE}
new_data_frame <- old_data_frame %>% 
  mutate(numeric_var = as.numeric(character_var))
```

This ties in nicely to the previous section where we detailed how to access the help files of a function. Help files will almost always describe what variable types are expected by a function. If you're trying to troubleshoot a function that isn't working, checking the help file and your argument types is always a good place to start.

#### Locating the problem in a chunk of code

There are a couple of good practices for locating the problem in a chunk of code

1. Not all error messages are helpful, but often times they will specify which function or operation is causing your    function to fail. 

2. After getting an error you can run the function `traceback()` in the console and this will show you the steps that    led up to the error. This is especially useful when a long chunk of code is throwing you an error

3. Add `print()` statements in your code. This can take a little bit of time to get used to, but the basic idea is 
   that by adding something like `print("got to here!") in your code, you'll still get an error, but you'll be able 
   to see if your code at least made it to that point successfully.
   
   Alternatively if you're creating objects in your code you can print those objects when they're created in the code
   to check if they're outputting what you expect.

4. Depending on what type of code you're writing you can always try using `#` at the start of a line to comment out lines of your code. If your code runs after you comment out a line, it's a good sign that the problem is happening there.
   
#### Being aware of NAs

Sometimes errors can arise when you compute summary statistics on a dataset. Here is an example of one such error. Let's try to compute the mean of bill length and body mass in the `penguins` dataset.

```{r}
penguins %>%
  summarise(mean_bill_length = mean(bill_length_mm),
            mean_body_mass = mean(body_mass_g))
```

The resulting dataset shows `NA` values where our means should be. This happens because there are `NA`s in these columns. Luckily, there is a very easy fix for this, using the argument `na.rm = TRUE`. This tells the `mean()` function to remove the `NA`s from its calculation. We can try the same summarization using `na.rm` like this:

```{r}
penguins %>%
  summarise(mean_bill_length = mean(bill_length_mm, na.rm = TRUE),
            mean_body_mass = mean(body_mass_g, na.rm = TRUE))
```

`na.rm` can be very useful when computing summary statistics, and is an argument that can be included in functions like `mean()`, `median()`, `sum()`, `min()`, `max()`, and more. 

